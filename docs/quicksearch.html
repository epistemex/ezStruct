<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" ezStruct Namespaces ezStruct Global defenumsname Global Members &lt;readonly&gt; enums :number Types enums definitions. Notice that there are several aliases included for convenience. Also notice the following: (U)LONG is 64-bit, (U)INT is 32-bit and (U)SHORT is 16 bit in this context. STRING is a NUL-terminated string and not an alias for CHAR. CHAR is a raw byte buffer. Use this type for undefined types and lengths. STRUCT is special for this solution and refer to a sub-structure (by name). Type: number Properties: Name Type Default Description UINT8 number 0 UBYTE number 0 UINT number 1 UINT16 number 1 USHORT number 1 UINT32 number 2 ULONG number 2 UINT64 number 3 ULONGLONG number 3 INT8 number 4 BYTE number 4 BOOL number 4 SHORT number 5 INT number 5 INT16 number 5 INT32 number 6 LONG number 6 INT64 number 7 LONGLONG number 7 FLOAT32 number 8 FLOAT number 8 FLOAT64 number 9 DOUBLE number 9 BIT8 number 10 BIT16 number 11 CHAR number 12 UCHAR number 13 BYTES number 13 STRING number 14 STRUCT number 15 name :string Type: string Methods def(type, name [, opt] [, opt2]) Define a new field in the structure. The structure will keep the same order as the definition order. CHAR, BYTES, STRING takes size (in bytes) as third argument. STRUCT takes name of a defined structure as third argument. Parameters: Name Type Argument Description type enums | number field type. name string | null field name. This will be the name you use in the code so make sure it will be valid, or call it using [&quot;!strange.name&quot;]. opt * &lt;optional&gt; used to set size for BIT8, BIT16, CHAR and STRING. For struct type a structure name or def. For other types this can be used to set a default value. opt2 * &lt;optional&gt; optional default data for CHAR, STRING, BIT8, BIT16 types. Type Definitions ezDefiner Definition object to define structures. Type: * × Search results Close Epistemex at GitHub "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" ezStruct Namespaces ezStruct Global defenumsname Namespaces Namespaces ezStruct × Search results Close Epistemex at GitHub "},"index.html":{"id":"index.html","title":"Index","body":" ezStruct Namespaces ezStruct Global defenumsname ezStructCreate virtual structures for binary data in JavaScript. Virtual structures are very useful for binary data packets and file parsing. Store structured data as bytes and send over the net in an highly efficient way. Features Define unlimited structures by name Define optional default values for each field Allocate memory for structures by name, size by definitions. Easy to define field types, names and sizes. Multi-level nested structures is supported Nested structures accessed using chained properties Read/write to/from structure fields using properties Supports char, string, struct, integers, floats fields Supports bit-field packing (unsigned 8 and 16 types). Export definitions as C-struct strings. Several convenient aliases for the enumerated types All data is written/read directly to/from the underlying ArrayBuffer which allows for efficient memory use as well fast read and write. InstallezStruct can be installed in various ways: Git using HTTPS: git clone https://github.com/epistemex/ezStruct.git Git using SSH: git clone git@github.com:epistemex/ezStruct.git Download zip archive and extract. UsageThe ezStruct is a global static object that manage structure definitions and memory allocations of those definitions. To define a new structure simply call: var s1 = ezStruct.define(&quot;myStruct1&quot;); var t = ezStruct.enums; // define fields s1.def(t.UINT32, &quot;field1&quot;); s1.def(t.UINT16, &quot;field2&quot;); s1.def(t.STRING, &quot;text&quot;, 100); // NUL-terminated UTF8 string, max 100 bytes s1.def(t.CHAR , &quot;data&quot;, 100); // raw char (byte) bufferNext, create the actual memory byte-buffer like this. This approach allows you to create several independent buffers for the same definitions: var m1 = ezStruct.alloc(&quot;myStruct1&quot;); // set fields m1.field1 = 0x12345678; m1.field2 = 0x1234; m1.text = &quot;Hello structures!&quot;; // read back var v1 = m1.field2; // =&gt; 0x1234 var str = m1.text; // =&gt; &quot;Hello structures!&quot; // get the raw byte buffer var bytes = m1.uint8; var arrBuffer = m1.buffer;Nested structure is possible (and recursively): var s2 = ezStruct.define(&quot;myStruct2&quot;); // Define an existing structure definition as field in this definition s2.def(t.STRUCT, &quot;subStruct&quot;, &quot;myStruct1&quot;); // type, field name, def. name s2.def(t.BOOL , &quot;status&quot;); // etc. // ... // allocate a buffer for the new defined structure var m2 = ezStruct.alloc(s2, {le: true}); // use def. for name, true = use little-endian // access nested struct using chained propterties. // Data written to same buffer as main structure. m2.subStruct.text = &quot;Hello sub-structure!&quot;;ezStruct also has bit-field support to pack flags tight to create very compact buffers: var bits = ezStruct.define(&quot;myFlags&quot;); // pack into Uint8 bits.def(t.BITS8, &quot;bitFld1&quot;, 1); // 1 bit width bits.def(t.BITS8, &quot;bitFld2&quot;, 3); // 3 bits width bits.def(t.BITS8, null, 0); // align to next byte bits.def(t.BITS8, &quot;bitFld3&quot;, 2); // 2 bits width // pack into Uint16 bits.def(t.BITS16, &quot;bitFld4&quot;, 4); // 4 bits width bits.def(t.BITS16, &quot;bitFld5&quot;, 4); // 4 bits width bits.def(t.BITS16, &quot;bitFld6&quot;, 2); // 2 bits width bits.def(t.BITS16, &quot;bitFld7&quot;, 6); // 6 bits width var bitMem = ezStruct.alloc(bits); // allocates 4 bytes bitMem.bitFld6 = 3; // sets all bits in bitFld6Export a definition as C-struct string: var bits = ezStruct.define(&quot;myFlags&quot;); var txt = ezStruct.defToC(bits); /* =&gt; struct myFlags { unsigned char bitFld1 : 1; unsigned char bitFld2 : 3; unsigned char :0; unsigned char bitFld3 : 2; unsigned int bitFld4 : 4; unsigned int bitFld5 : 4; unsigned int bitFld6 : 2 unsigned int bitFld7 : 6 };Also see ezBuffers - enhanced data-view. Includes bit-tools (ezBits). IssuesSee the issue tracker for details. ContributorsSee contributors here. LicenseReleased under MIT license. You may use this class in both commercial and non-commercial projects provided that full header (minified and developer versions) is included. © Epistemex 2018 × Search results Close Epistemex at GitHub "},"ezStruct.html":{"id":"ezStruct.html","title":"Namespace: ezStruct","body":" ezStruct Namespaces ezStruct Global defenumsname Namespace: ezStruct ezStruct ezStruct allows for defining and creating binary structures. Methods &lt;static&gt; alloc(name [, options]) Allocates the actual memory for the structure and provides properties to set or get each field. The size of the buffer depends on the field definitions. Parameters: Name Type Argument Description name string | * the name of the structure to allocate memory for. You can also pass in a structure definition instead of name. options * &lt;optional&gt; various options Properties Name Type Argument Description le boolean &lt;optional&gt; endianess, defaults to big-endian. Set to true for little-endian. buffer ArrayBuffer &lt;optional&gt; use this buffer instead of allocating one new. offset number &lt;optional&gt; use the given buffer from this offset (in bytes). Returns: The returned buffer object can be used to update the structure buffer. The available properties depends on the field definitions. Common properties for all buffers are: buffer, uint8, view, name and length. Type * &lt;static&gt; clone(memStruct) Clones a allocated structure and the content of the source structure buffer. Parameters: Name Type Description memStruct * source structure buffer Returns: New instance of a allocated structure Type * &lt;static&gt; define(name) Create a new structure definition. Parameters: Name Type Description name string internal name of this structure. This name is used with alloc() and with definition type enums.STRUCT. Returns: Contains method def to define each field. Type ezDefiner &lt;static&gt; defToC(name) Create a C-struct string from a definition. Parameters: Name Type Description name string | * name of definition to return or the definition object Throws: If definition name is not found an error is thrown. Returns: A string holding the C-struct Type string &lt;static&gt; fromBuffer(name, buffer [, le]) Creates a new structure buffer and fills it with data from given buffer. If the source buffer is shorter than structure buffer the data is filled from the beginning. If larger then the data is truncated to fit into the structure buffer. Parameters: Name Type Argument Default Description name string name of structure to create and fill. buffer * source buffer (ArrayBuffer or a TypedArray view). le boolean &lt;optional&gt; false little-endian flag Returns: New structure with filled buffer Type * &lt;static&gt; getDef(name) Get a definition object by name. Parameters: Name Type Description name string name of definition to return Returns: The definition if found, else null Type * × Search results Close Epistemex at GitHub "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
